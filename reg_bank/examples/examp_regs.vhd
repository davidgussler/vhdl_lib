-- #############################################################################
-- #  << examp_regs >>
-- # ===========================================================================
-- # File             : examp_regs.vhd
-- # Language         : VHDL '08
-- # Generator Author : David Gussler
-- #
-- # Generated by reggie v0.1.0 on July 12, 2023 at 11:05 am est
-- #
-- # !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-- # !! Warning - This is generated file. Do not edit. !! 
-- # !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-- #
-- # ===========================================================================
-- # Description of this example register map
-- # This is the long description for this register map. As you can clearly see, 
-- # this verbose description is much more wordy than the regular description, 
-- # and it is allowed to span many lines. It is optional to add this, but 
-- # highly recommended.
-- #############################################################################

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.gen_utils_pkg.all;
use work.examp_regs_pkg.all; 

entity examp_regs is
    port (
        i_clk : in std_logic;
        i_rst : in std_logic;

        -- Bus Interface
        i_s_bus : in  bus_req_t; 
        o_s_bus : out bus_resp_t;

        -- Register Interface
        o_ctl : out examp_regs_ctl_t;
        i_sts : in  examp_regs_sts_t;

        -- Register R/W Indication Interface
        o_wr : out examp_regs_wr_t;
        o_rd : out examp_regs_rd_t
    );
end entity examp_regs;

architecture rtl of examp_regs is
    signal ctl : slv_array_t(EXAMP_REGS_NUM_REGS-1 downto 0)(31 downto 0);
    signal sts : slv_array_t(EXAMP_REGS_NUM_REGS-1 downto 0)(31 downto 0) := (others=>(others=>'0'));
    signal rd : std_logic_vector(EXAMP_REGS_NUM_REGS-1 downto 0);
    signal wr : std_logic_vector(EXAMP_REGS_NUM_REGS-1 downto 0); 
begin
    u_examp_regs_reg_bank : entity work.reg_bank
    generic map (
        G_NUM_REGS  => EXAMP_REGS_NUM_REGS,
        G_ADDR_BITS => EXAMP_REGS_ADDR_BITS,
        G_ADDRS     => EXAMP_REGS_ADDRS,
        G_RST_VALS  => EXAMP_REGS_RST_VALS
    )
    port map (
        i_clk   => i_clk,
        i_rst   => i_rst,
        i_s_bus => i_s_bus,
        o_s_bus => o_s_bus,
        o_ctl   => ctl,
        i_sts   => sts,
        o_wr    => wr,
        o_rd    => rd
    );

    -- RW
    o_ctl.reg0.fld0 <= ctl(0)(0);
    o_ctl.reg0.fld1 <= ctl(0)(11 downto 8);
    o_ctl.reg1_arr(0).fld0 <= ctl(1)(3 downto 2);
    o_ctl.reg1_arr(0).fld1 <= ctl(1)(15 downto 8);
    o_ctl.reg1_arr(1).fld0 <= ctl(2)(3 downto 2);
    o_ctl.reg1_arr(1).fld1 <= ctl(2)(15 downto 8);
    -- Loopback for RW
    sts(0)(0) <= ctl(0)(0);
    sts(0)(11 downto 8) <= ctl(0)(11 downto 8);
    sts(1)(3 downto 2) <= ctl(1)(3 downto 2);
    sts(1)(15 downto 8) <= ctl(1)(15 downto 8);
    sts(2)(3 downto 2) <= ctl(2)(3 downto 2);
    sts(2)(15 downto 8) <= ctl(2)(15 downto 8);

    -- RO
    sts(3)(31 downto 0) <= i_sts.reg2.fld0; 

    -- RWV
    o_ctl.reg3.fld0 <= ctl(4)(23 downto 0);
    sts(4)(23 downto 0) <= i_sts.reg3.fld0; 

    -- Read indication pulses
    o_rd.reg0 <= rd(0);
    o_rd.reg1_arr(0) <= rd(1);
    o_rd.reg1_arr(1) <= rd(2);
    o_rd.reg2 <= rd(3);
    o_rd.reg3 <= rd(4);

    -- Write indication pulses
    o_wr.reg0 <= wr(0);
    o_wr.reg1_arr(0) <= wr(1);
    o_wr.reg1_arr(1) <= wr(2);
    o_wr.reg3 <= wr(4);

end architecture;
